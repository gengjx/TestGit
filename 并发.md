
# 一、线程实现

```
有三种使用线程的方法：

- 实现 Runnable 接口；

- 实现 Callable 接口；

- 继承 Thread 类。

  实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。
```



## **实现 Runnable 接口**

需要实现接口中的 run() 方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
```

使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。

## 实现 Callable 接口

与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return null;
    }
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

## 继承 Thread 类

同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

## 区别比较：

### 	接口与类比较

​		实现接口会更好一些，因为：

​			Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；

​			类可能只要求可执行就行，继承整个 Thread 类开销过大。

### 	Runnable和Callable

​	（1）是否有返回值 	Callable 可以有返回值,Runnable无返回值
​	（2）是否抛异常		Callable 可以抛异常
​    （3）落地方法不一样，一个是run，一个是call



# 二、基础线程机制

## Executor

Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 Executor：

- CachedThreadPool：一个任务创建一个线程；
- FixedThreadPool：所有任务只能使用固定大小的线程；
- SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
```

## Daemon

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。

​	 thread.setDaemon(true);

## sleep()

Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

Thread.sleep(3000);

## yield()

​	对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

​	Thread.yield();



# 三、同步与互斥

## volatile

**volatile 作用**

```
	当多个线程进行操作共享数据时，可以保证内存中的数据可见。
	相较于 synchronized 是一种较为轻量级的同步策略。
目的：
	防止指令重排
	保证变量的可见性
原因：
	当前Java内存模型，不是从主存读取变量，而是将变量保存在本地内存(寄存器)。
	可能存在 一个线程修改【主存】中的变量值，而另一个线程仍使用【本地内存】中的变量拷贝值，造成【数据】不一致。
	变量声明为volatile，即告知JVM该变量不稳定。每次要在主存中读取值。 
```

**Synchronized 和 volatile 的区别**

```
1. 是否阻塞
   volatile 不会造成阻塞，Synchronized会造成阻塞
2. 作用范围不同
   volatile 只能修饰变量， Synchronized 修饰 代码块和 方法 
3. 作用不同
   volatile主要用于保证变量在多个线程之间的可见性，而Synchronized则是保证临界资源在多个线程之间的同步性
   volatile 仅保证变量的可见性，而不保证原子性。Synchronized两者都能保证
4. 效率
   volatile是线程同步的轻量级实现，效率高于Sychronized
```



Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。

## synchronized

**同步：**

```java
1.同步一个代码块
	synchronized (this) {
    }
只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。

2. 同步一个方法   
    public synchronized void func () {
    }
它和同步代码块一样，作用于同一个对象。

3. 同步一个类
	synchronized (SynchronizedExample.class) {
    }
作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。

4. 同步一个静态方法 
    public synchronized static void fun() {
	}
作用于整个类
```



**单例模式 双重校验锁**

```java
Class Singleton{
        private volatile static Singleton uniqueInstance ;   
        private Singleton(){
            // 私有构造器     
        } 
        private static Singleton getInstance(){ 
            if(uniqueInstance==null){ // 检测单例是否已经创建
                Synchronized(Singleton.class){
                    if(uniqueInstance==null){ // 检测其他线程是否先获取锁创建了单例对象
                        uniqueInstance = new Singleton();
                    }
                }
            }
            return uniqueInstance ; 
        }
    }
```

 

**Synchronized的底层优化**

```
	JDK1.6后底层优化
	四种锁状态 ： 无锁 --> 偏向锁 --> 轻量级锁 --->重量级锁
    锁随着【竞争程度】上升，逐渐升级。但不可降级。
    
    1. 【初次执行Synchronized代码块】，锁对象变为【偏向锁】
        (通过CAS操作修改对象头中【锁标志位】和【持锁线程ID】)。
        (偏向锁意为偏向于第一个获取它的线程)。执行完同步块后，线程不主动释放偏向锁。
        当执行下一个同步块时，检测该当前想要获取锁的线程是否就是持有锁的线程。
        如果是，则正常执行。【线程没有释放锁，因此也不用重新加锁】
        
    2. 【一旦出现锁竞争】，偏向锁升级为【轻量级锁】。
        如果锁标志位=释放，则线程通过【CAS操作】修改锁标志位，并获取锁。
        如果锁标志位=锁定，则线程通过【自旋】等待锁的释放。
        自旋：一个线程获取锁，其他线程通过忙循环等待线程释放锁。
        轻量级锁本质 = 【忙等开销 换取 用户态切换到核心态的开销】
        
    3. 【忙等是有限度】，当某个线程自旋次数达到最大自选次数。
        该线程通过CAS操作修改对象头的锁标志位，表明轻量级锁升级为【重量级锁】
        一个线程持有锁时，其他请求线程只能阻塞等待。    
    
```



**synchronized 底层**

```
Sychronized 修饰 代码块 || 方法 
    1.修饰代码块时 
        通过 【monitorenter 和 monitorExit 两条指令】，分别指定同步代码块的 开始位置和结束位置。
        线程获取锁 = 获取位于对象头的monitor的持有权
        获取到锁，则计数器++。 执行到monitorExit，则计数器--
        
    2.修饰方法 
        JVM通过 ACC_SYNCHRONIZED 辨别方法为同步方法 
    【面试口头】
        Sychronized 是【JVM】层面的关键字。它是通过 【字节码指令】实现的。
           (1) Sychronized 修饰 【代码块】时，montior-enter monitor-exit两个字节码指令表明 同步块的开始和结束位置。
           (2) Sychronized 修饰 【方法】时，JVM中通过ACC_SYCHRONIZED 标志同步方法 
```



## ReentrantLock

ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。

​	**模板：**

```java
private Lock lock = new ReentrantLock();
public void func() {
	lock.lock();
	try {
            //
	} finally {
		lock.unlock(); // 确保释放锁，从而避免发生死锁。
    }
}
```



## ReadWriteLock 

读写锁

​	读 - 读： 不互斥

​	写 - 写：互斥

​	读 - 写：互斥

**模板：**

```java
class ReadWriteLockDemo{
	private int number = 0;
	private ReadWriteLock lock = new ReentrantReadWriteLock();
	//读
	public void get(){
		lock.readLock().lock(); //上锁
		try{
			System.out.println(Thread.currentThread().getName() + " : " + number);
		}finally{
			lock.readLock().unlock(); //释放锁
		}
	}
	//写
	public void set(int number){
		lock.writeLock().lock();
		try{
			System.out.println(Thread.currentThread().getName());
			this.number = number;
		}finally{
			lock.writeLock().unlock();
		}
	}
}
public class TestReadWriteLock {
	public static void main(String[] args) {
		ReadWriteLockDemo rw = new ReadWriteLockDemo();
		new Thread(new Runnable() {
			@Override
			public void run() {
				rw.set((int)(Math.random() * 101));
			}
		}, "Write:").start();
		for (int i = 0; i < 100; i++) {
			new Thread(new Runnable() {		
				@Override
				public void run() {
					rw.get();
				}
			}).start();
		}
	}
}
```



**ReentrantLock 和 Sychronized 区别**

```
1. 锁的实现
	synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

2. 性能 
	对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。
	两者都是【可重入锁】 : 获得某一对象锁时，若自己未释放，也可重复再次获得该对象的锁 。 锁计数器++ 

3. 等待可中断
	当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
	ReentrantLock 可中断，而 synchronized 不行。

4. 公平锁 
	公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。
	synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

5. 锁绑定多个条件
	一个 ReentrantLock 可以同时绑定多个 Condition 对象。

6.等待机制
	Sychronized 通过 notiy() notifyAll() wait() 实现等待/通知机制
            ReentrantLock 通过 Condition对象实现。
	一个lock可创建多个Condition对象，一个Condition对象可注册多个线程。
               Condition 对象调用signal ||signalAll() 
                    唤醒线程所在范围 =  注册的线程，
                而Sychronized 调用 notify() || notifyAll() 
                    唤醒线程 = JVM选择的
                因此 ReentrantLock的等待通知机制更加灵活

```



## 使用选择

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。



# 四、线程通信协作

## 	生产者消费者模式：

**多线程编写模板：**

​	线程 -- 操作 -- 资源类

​	判断 -- 通知 -- 干活

**注意：虚假唤醒问题**

```java
//资源类
class Clerk{
	private int product = 0;
	//操作
	public synchronized void get(){//循环次数：0
        //判断
		while(product >= 1){//为了避免虚假唤醒问题，应该总是使用在循环中
			try {
				this.wait();
			} catch (InterruptedException e) {
			}
		}
        //干活
		System.out.println(Thread.currentThread().getName() + " : " + ++product);
		//通知
        this.notifyAll();
	}
	public synchronized void sale(){
		while(product <= 0){
			try {
				this.wait();
			} catch (InterruptedException e) {
			}
		}
		System.out.println(Thread.currentThread().getName() + " : " + --product);
		this.notifyAll();
	}
}
//线程
class Test{
	Clerk clerk=new Clerk();
    new Thread(new Runnable() {
        @Override
        public void run(){
             for (int i = 1; i <=40; i++){
                clerk.sale();
             }
        }
   }, "AA").start();
	
    new Thread(new Runnable() {
        @Override
        public void run() {
             for (int i = 1; i <=40; i++) {
                clerk.sale();
             }
        }
	}, "AA").start();
}

```



## 	线程交替打印：

​	 2 个线程，这2个线程的 ID 分别为 A、B；每个线程将自己的 ID 在屏幕上打印 10 遍， ABABABAB.....

```java
//资源类
class AlternateDemo{
	private int number = 1; //当前正在执行线程的标记
	private Lock lock = new ReentrantLock();
	private Condition condition1 = lock.newCondition();
	private Condition condition2 = lock.newCondition();
	//操作
    public void loopA(int totalLoop){
		lock.lock();
		try {
			//1. 判断
			if(number != 1){
				condition1.await();
			}
			
			//2. 干活
			for (int i = 1; i <= 1; i++) {
				System.out.println(Thread.currentThread().getName());
			}
			//3. 通知
			number = 2;
			condition2.signal();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
	public void loopB(int totalLoop){
		lock.lock();
		try {
			//1. 判断
			if(number != 2){
				condition2.await();
			}
			//2. 干活
			for (int i = 1; i <= 1; i++) {
				System.out.println(Thread.currentThread().getName());
			}
			//3. 通知
			number = 1;
			condition1.signal();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
}
//线程
public class TestABCAlternate {
	public static void main(String[] args) {
		AlternateDemo ad = new AlternateDemo();
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 1; i <= 20; i++) {
					ad.loopA(i);
				}
			}
		}, "A").start();
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 1; i <= 20; i++) {
					ad.loopB(i);
				}
			}
		}, "B").start();
}
```



## 		join()

​		在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。



## 		wait() & notify() & notifyAll()

​		调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。

​		只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。

​		使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

​	**wait() 和 sleep() 的区别**  

- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- wait() 会释放锁，sleep() 不会。



## 		await() & signal() & signalAll()

​		java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

​		在lock锁的情况下使用。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

​		使用 Lock 来获取一个 Condition 对象。



# 五、线程状态

一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。

​	**新建（NEW）**

​		创建后尚未启动。

​	**可运行（RUNABLE）**

​		正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度，资源调度完成		就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。

​	**阻塞（BLOCKED）**

​		请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor 			lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。

​	**无限期等待（WAITING）**

​		等待其它线程显式地唤醒。

​		阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。

​		而等待是主动的，通过调用  Object.wait() 等方法进入。

| 进入方法 | 退出方法 |
| --- | --- |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕 |
| LockSupport.park() 方法 | LockSupport.unpark(Thread) |

​	**限期等待（TIMED_WAITING）**

​		无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

| 进入方法 | 退出方法 |
| --- | --- |
| Thread.sleep() 方法 | 时间结束 |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll()  |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕 |
| LockSupport.parkNanos() 方法 | LockSupport.unpark(Thread) |
| LockSupport.parkUntil() 方法 | LockSupport.unpark(Thread) |

​		调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。

​		调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。

​		睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

​	**死亡（TERMINATED）**

​		可以是线程结束任务之后自己结束，或者产生了异常而结束。



# 六、AQS & CAS

java.util.concurrent（JUC）大大提高了并发性能，AQS 被认为是 JUC 的核心。

## AQS

​	AbstractQuenedSynchronizer**抽象的队列式同步器**。

​	是除了java自带的synchronized关键字之外的锁机制，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架。

**核心思想：**

​	线程请求资源；如果资源空闲，则 请求线程设置为工作线程，资源上锁
​        						如果资源被占用  则 请求线程阻塞，加入CLH队列。等待资源空闲时竞争资源
​    ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的。 

**同步状态：**

​	AQS 的主要使用方式是**继承**，子类通过继承同步器，并实现它的**抽象方法**来管理同步状态。

​	AQS 使用一个 `int` 类型的成员变量 `state` 来**表示同步状态**：

​		当 `state > 0` 时，表示已经获取了锁。

​		当 `state = 0` 时，表示释放了锁。

​	它提供了三个方法，来对同步状态 `state` 进行操作，并且 AQS 可以确保对 `state` 的操作是**安全**的：

​		`#getState()`

​		`#setState(int newState)`

​		`#compareAndSetState(int expect, int update)`

**资源共享：**

    1. 独占锁 Exclusive  ： 锁只能被一个线程占有
        例如 ： ReentrantLock 又分为 公平锁和非公平锁

   2. 共享锁 shared    ： 多个线程共享锁
        例如 ： CountDownLatch 、Semaphore

   3.  实现的方法：AQS框架 自定义模块

        ​    尝试 获取/释放 独占资源
        ​    	tryAcquire()
        ​    	tryRelease()
        ​    尝试 获取/释放共享资源
        ​    	tryAcquireShared()
        ​    	tryReleaseShared()

**节点模式：**

​	**独占锁获取锁时，设置节点模式为Node.EXCLUSIVE**

 		独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待。		该方法将会调用**可重写**的 `tryAcquire(int arg)` 方法

​		 `acquireInterruptibly(int arg)`：与 `#acquire(int arg)` 相同，但是该方法响应中断。当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 异常并返回。

​	**共享锁获取锁，节点模式则为Node.SHARED:**

**主要内置方法：**

1. `#tryAcquire(int arg)`：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态。
2. `#tryRelease(int arg)`：独占式释放同步状态。
3. `#tryAcquireShared(int arg)`：共享式获取同步状态，返回值大于等于 0 ，则表示获取成功；否则，获取失败。
4. `#tryReleaseShared(int arg)`：共享式释放同步状态。
5. `#isHeldExclusively()`：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占。
6. `#tryAcquireNanos(int arg, long nanos)`：超时获取同步状态。如果当前线程在 nanos 时间内没有获取到同步状态，那么将会返回 false ，已经获取则返回 true 。
7. `#acquireShared(int arg)`：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；
8. `#acquireSharedInterruptibly(int arg)`：共享式获取同步状态，响应中断。
9. `#tryAcquireSharedNanos(int arg, long nanosTimeout)`：共享式获取同步状态，增加超时限制。
10. `#release(int arg)`：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。
11. `#releaseShared(int arg)`：共享式释放同步状态。



**CLH同步队列：**

AQS 通过内置的 FIFO 同步队列来完成资源获取线程的**排队工作**：

- 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程
- 当同步状态**释放**时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。

  CLH阻塞队列采用的是双向链表队列，头部节点默认获取资源获得执行权限。后续节点不断自旋方式查询前置节点是否执行完成，直到头部节点执行完成将自己的waitStatus状态修改以通知后续节点可以获取资源执行。 

![image](file:///C:/Users/qqq/AppData/Local/YNote/data/qqEC3F002AF1032EED0A5CFBC343ACBCCA/c09d2e874ebe49a8b7a4c3db702df31f/clipboard.png?ynotemdtimestamp=1598594893365)

## CAS

 	CAS(Compare And Swap)，即比较并交换。 

​	提供**硬件级别的原子操作**。 是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B) 



# 七、JUC 辅助类&组件

##  辅助类

### CountDownLatch

​	用来控制一个或者多个线程等待多个线程。

​	维护了一个计数器 count，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 		await() 方法而在等待的线程就会被唤醒。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" width="300px"> </div><br>
```java
public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("run..");
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println("end");
        executorService.shutdown();
    }
}
```



### CyclicBarrier

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
```

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" width="300px"> </div><br>
```java
public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("before..");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print("after..");
            });
        }
        executorService.shutdown();
    }
}
```

```html
before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
```

### Semaphore

Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。

以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

```java
public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
```

```html
2 1 2 2 2 2 2 1 2 2
```



## 组件

### FutureTask

在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future<V> 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future<V> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。

```java
public class FutureTask<V> implements RunnableFuture<V>
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V>
```

FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。

```java
public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<Integer>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i < 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });

        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -> {
            System.out.println("other task is running...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}
```

```html
other task is running...
4950
```

### BlockingQueue

java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：

-   **FIFO 队列**  ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
-   **优先级队列**  ：PriorityBlockingQueue

提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。

**使用 BlockingQueue 实现生产者消费者问题**  

```java
public class ProducerConsumer {

    private static BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);

    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put("product");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print("produce..");
        }
    }

    private static class Consumer extends Thread {

        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print("consume..");
        }
    }
}
```

```java
public static void main(String[] args) {
    for (int i = 0; i < 2; i++) {
        Producer producer = new Producer();
        producer.start();
    }
    for (int i = 0; i < 5; i++) {
        Consumer consumer = new Consumer();
        consumer.start();
    }
    for (int i = 0; i < 3; i++) {
        Producer producer = new Producer();
        producer.start();
    }
}
```

```html
produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..
```

### ForkJoin

主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。

```java
public class ForkJoinExample extends RecursiveTask<Integer> {

    private final int threshold = 5;
    private int first;
    private int last;

    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first <= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i <= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}
```

ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。

```java
public class ForkJoinPool extends AbstractExecutorService
```

ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" width="300px"> </div><br>
# 八. ThreadLocal

作用 ： 和每个线程绑定专属的本地变量

**ThreadLocal 底层原理**

每个Thread对象中具备threadLocalMap ，而threadLocalMap中存储 key=threadLocal的键值对。 ThreadLocal.get() threadLocal.set();

**软引用 & 弱引用**

```
    虚引用-> 弱引用 -> 软引用 -> 强引用
    弱引用被GC线程发现后，不论内存空间是否不足，都立刻回收
    软引用被GC线程发现后，如果内存空间不足，则回收
```



# 九、线程池

## 线程池的优势特点

```java
线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

它的主要特点为：线程复用;控制最大并发数;管理线程。
	第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。	
	第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。
	第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，			使用线程池可以进行统一的分配，调优和监控。
```



## 线程池种类

```java
线程池的体系结构：
   	java.util.concurrent.Executor : 负责线程的使用与调度的根接口
   		|--ExecutorService 子接口: 线程池的主要接口
  			|--ThreadPoolExecutor 线程池的实现类
  			|--ScheduledExecutorService 子接口：负责线程的调度
   	  			|--ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor，
                         实现ScheduledExecutorService

工具类 : Executors 
	1、ExecutorService newFixedThreadPool() : 创建固定大小的线程池
	2、ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，
												可以根据需求自动的更改数量。
	3、ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程
	4、ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程
															可以延迟或定时的执行任务。

//创建执行过程														
    ExecutorService pool = Executors.newFixedThreadPool(5);
    pool.submit(new Thread());
    pool.shutdown();
```



## **线程池执行原理**

```
1、在创建了线程池后，开始等待请求。
2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：
  1）如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；
  2）如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；
  3）如果队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；
  4）如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。
3、当一个线程完成任务时，它会从队列中取下一个任务来执行。
4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：
    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。
    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。
```



## 线程池核心参数

```
1.corePoolSize：		指定了线程池中的线程数量
2.maximumPoolSize：	指定了线程池中的最大线程数量
3.keepAliveTime：	当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过了 							corePoolSize空闲线程，在多长时间内，会被销毁。
4.unit: 			 keepAliveTime 的单位。
5.workQueue：		任务队列，被提交但尚未被执行的任务。
6.threadFactory：	线程工厂，用于创建线程，一般用默认的即可。
7.handler：			拒绝策略。当任务太多来不及处理，如何拒绝任务。
```



# 十、线程锁

## java锁分类

​	1.**悲观锁和乐观锁**：线程能否锁住同步资源

​	2.**阻塞和自旋锁**：锁住同步资源失败是否阻塞

​	3.**无锁、偏向锁、轻量级锁、重量级锁**：多个线程竞争同步资源的流程细节区别

​	4.**公平锁和不公平锁：**多个线程竞争时是否排队

​	5.**可重入锁和不可重入锁：**一个线程多个流程能否获取同一把锁

​	6.**共享锁和互斥锁：**多个线程能否共享一把锁

​	下面我们依照序号依次的介绍每一种锁

![img](https://img-blog.csdnimg.cn/20190505195114634.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70)

##  悲观锁和乐观锁

```
悲观锁和乐观锁是一种广义的概念，体现的是看待线程同步的不同的角度
悲观锁：
	认为在使用数据的时候，一定有别的线程来修改数据，在获取数据的时候会先加锁，确保数据不会被别的线程修改。
	锁实现：关键字synchronized、接口Lock的实现类
	使用的场景：写操作较多，先加锁可以保证写操作是数据正确
乐观锁:
	认为在使用数据时不会有其他的线程修改数据，所以不会添加锁，只是在更新数据前判断有没有别的线程更新数据
	锁实现：CAS算法
	使用场景：读操作较多，不加锁的特点能够使其读操作的性能大幅提升
```



## 阻塞和自旋锁

是指当一个线程在获取锁的饿时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断判断是否能够被成功获取，自旋知道获取到锁才会退出循环。自旋是通过CAS算法进行的。何为CAS算法呢？

CAS(compare and swap)：比较和交换，顾名思义就是先进行比较然后在进行交换。这里比较和交换是线程中的数据和内存中的数据之间的操作。

如下图所示：**1** 线程1和线程2都读取内存中的数据V赋值给A ***\*2\**** 线程1把V的值由0改为了1，并想把修改后的值写回到内存 **3** 线程1将A的值和V的值进行比较 **4** 两者相等，说明没有线程对V的值进行修改，直接把修改后的值（B=1）写入内存，此时，V=1。**3** 线程2进行将A的值和V的值进行比较 **5** 两者不相等，说明有线程对V的值进行修改，此时线程2不能够把修改后的值写入内存，因为它获得的A的值不是最新的，由A得到的B的值也可能是错误的。线程2会读取A的值，重新计算出B的值，再尝试重新写入，如果还是不相等在继续尝试，不断的自旋。

![img](https://img-blog.csdnimg.cn/20190505201114825.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70)

我们发现CAS算法存在一个非常明显的缺陷，那就是ABA问题。何为ABA问题呢？

如下图所示:线程1线程2 线程3 都获取A=V=0 **1** 线程1修改V的值为1 写入内存 **2** 线程2 把v的值改为2，但是没来的及写入，线程3 就开始运行 ***\*3\**** 线程3 将V的值改为0 写入内存 **4** 线程2 比较A和V的值发现A=V，他自认为没有其他的线程对V进行修改，因而忽略了A->B->A的过程，形成了ABA问题。ABA的问题解决方法很简单：AtomicStampedReference在变量前面添加版本号，每次变量更新的时候都把版本号加一。

 

![img](https://img-blog.csdnimg.cn/20190505202907828.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70)

我们知道自旋是会消耗CPU资源的（不断循环），为什么不用阻塞的方式使等待的线程停止工作呢？原因有两个

（1）同步代码块逻辑简单情况下，自旋消耗的资源时很少的（在同步代码块逻辑简单的情况下，用自旋是比较合适的）

（2）最为关键的原因是阻塞与唤醒线程需要操作系统切换CPU状态，需要消耗一定的时间（CPU上下文切换）

那么为什么阻塞和唤醒线程会消耗大量时间呢？

因为线程的阻塞唤醒涉及大量的步骤，我们以线程阻塞为例进行说明

![img](https://img-blog.csdnimg.cn/20190505210834348.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70)

步骤1：线程1获取CPU时间片执行

步骤2：线程1被阻塞，上下文切换

步骤3：线程2抢占CPU时间片执行

步骤2涉及两个子步骤：

步骤2.1 从用户态切换到内核态

为什么要进行这种切换呢？

用户是没有权限对内存进行操作，我们要切换到内核态才有权对内存进行操作。

步骤2.2 把线程1的状态保存到PCB(内存)

我们到底要保存线程的哪些信息呢？

一个线程在运行时的内存模型主要有5个部分组成：（1）程序计数器：记录下一条指令的地址（2）虚拟机栈：保存函数的信息，例如，局部的变量，函数返回地址，操作数等（3）本地方法栈：和虚拟机栈类似，不过其保存的函数的信息是native函数（4）方法区：保存类的信息，静态变量等（5）堆：实例化的对象（堆是用户申请的（C语言中malloc函数），而栈是系统自动分配的）。很明显：程序计数器、虚拟机栈、方法区、堆等信息都会被保存到内存中。

可见上下文切换是非常耗时的。



## 无锁、偏向锁、轻量级锁、重量级锁

![img](https://img-blog.csdnimg.cn/2019050520033413.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70)

```
随着竞争不断的加剧，锁要不断的升级。
（1）无锁：适用于单线程、
（2）偏向锁：适用于只有一个线程访问同步块的情况，因为多个线程同时访问同步块，给某一个线程特权是不合理的（3）轻量级锁：竞争不是太多，循环等待消耗CPU资源的线程的数量在可接受的范围
（4）重量级锁：多个线程同时竞争资源，只让一个线程运行，其余的线程都阻塞
```



## 可重入锁和不可重入锁

​	可重入锁：一个线程可以多次获得同一把锁并通过state记录加了多少锁



## 公平锁和非公平锁

```
公平锁和非公平锁主要是关于等待的线程的排队的问题，这个排队要利用AQS（AbstractQueuedSynchronizer）

我们以重入锁（ReentrantLock）为例解释AQS。AQS由三个部分组成，State：当前线程锁的个数、exclusiveOwerThread：当前占有锁的线程 、CLH队列等待运行的线程。

**1** 线程1 CAS算法A=V(state)=0，修改state的值为1 **2** 线程1又想获取锁，此时A=V(state)=1，state再加1,无论A想获得多少次，只是state+1 **3** 线程2 进行CAS比较，发现A不等于V，并且发现state不等于0，直接到CLH列队中等待。线程3和线程4也一样到CLH队列中等待。如果先来的线程先排队，获取锁的优先权，则为公平锁。如果，无视等待队列，直接尝试获取锁，则为非公平锁。
```

![img](https://img-blog.csdnimg.cn/20190505204255694.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70)

队列如果已经满了，该怎么办呢？

无法进入队列的线程，进入ArrayBlockingQueue,等队列有空位再进入队列



## 互斥锁和共享锁

```
互斥锁：在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。

共享锁：共享锁从字面来看也即是允许多个线程共同访问资源。

互斥锁很容易理解，上锁之后，其他线程都阻塞了。

共享锁一个典型的例子就是读者写者模式，一个人写多个人去读，写者写出的东西，多个读者是可以一块去读的，这就是多个读者共享一个同步资源。

共享锁--用到共享锁的有Semapore信号量和ReadLock读锁
```



## 线程八锁

```
A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，
其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法
锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法

加个普通方法后发现和同步锁无关
换成两个对象后，不是同一把锁了，情况立刻变化。


synchronized实现同步的基础：Java中的每一个对象都可以作为锁。
具体表现为以下3种形式。
对于普通同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步方法块，锁是Synchonized括号里配置的对象

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，
可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，
所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。

所有的静态同步方法用的也是同一把锁——类对象本身，
这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。
但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，
而不管是同一个实例对象的静态同步方法之间，
还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！
```



# 十一、锁优化

这里的锁优化主要是指 JVM 对 synchronized 的优化。

## 自旋锁

互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。

## 锁消除

锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。

锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。

对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：

```java
public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
```

String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：

```java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。

## 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

## 轻量级锁

JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" width="500"/> </div><br>
下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png" width="500"/> </div><br>
轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png" width="400"/> </div><br>
如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

## 偏向锁

偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" width="600"/> </div><br>
# 十三、多线程开发良好的实践

- 给线程起个有意义的名字，这样可以方便找 Bug。

- 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。

- 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。

- 使用 BlockingQueue 实现生产者消费者问题。

- 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。

- 使用本地变量和不可变类来保证线程安全。

- 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。



# 十、Java 内存模型

Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

## 主内存与工作内存

处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。

加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" width="600px"> </div><br>
所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。

线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" width="600px"> </div><br>
## 内存间交互操作

Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" width="450px"> </div><br>
- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：作用于主内存的变量
- unlock

## 内存模型三大特性

### 1. 原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。

有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。

为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。

下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" width="300px"> </div><br>
AtomicInteger 能保证多个线程修改的原子性。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" width="300px"> </div><br>
使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：

```java
public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
1000
```

除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。

```java
public class AtomicSynchronizedExample {
    private int cnt = 0;

    public synchronized void add() {
        cnt++;
    }

    public synchronized int get() {
        return cnt;
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicSynchronizedExample example = new AtomicSynchronizedExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
1000
```

### 2. 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

主要有三种实现可见性的方式：

- volatile
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。

### 3. 有序性

有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

## 先行发生原则

上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。

### 1. 单一线程原则

> Single Thread rule

在一个线程内，在程序前面的操作先行发生于后面的操作。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" width="180px"> </div><br>
### 2. 管程锁定规则

> Monitor Lock Rule

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" width="350px"> </div><br>
### 3. volatile 变量规则

> Volatile Variable Rule

对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png" width="400px"> </div><br>
### 4. 线程启动规则

> Thread Start Rule

Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" width="380px"> </div><br>
### 5. 线程加入规则

> Thread Join Rule

Thread 对象的结束先行发生于 join() 方法返回。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png" width="400px"> </div><br>
### 6. 线程中断规则

> Thread Interruption Rule

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

### 7. 对象终结规则

> Finalizer Rule

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

### 8. 传递性

> Transitivity

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

# 十一、线程安全

多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。

线程安全有以下几种实现方式：

## 不可变

不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。

不可变的类型：

- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。

对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。

```java
public class ImmutableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put("a", 1);
    }
}
```

```html
Exception in thread "main" java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
```

Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。

```java
public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
```

## 互斥同步

synchronized 和 ReentrantLock。

## 非阻塞同步

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

### 1. CAS

乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。

### 2. AtomicInteger

J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。

以下代码使用了 AtomicInteger 执行了自增的操作。

```java
private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}
```

以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。

```java
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。

可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

### 3. ABA

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

## 无同步方案

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。

### 1. 栈封闭

多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。

```java
public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i < 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}
```

```java
public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> example.add100());
    executorService.execute(() -> example.add100());
    executorService.shutdown();
}
```

```html
100
100
```

### 2. 线程本地存储（Thread Local Storage）

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。

可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。

对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。

```java
public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -> {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}
```

```html
1
```

为了理解 ThreadLocal，先看以下代码：

```java
public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -> {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
```

它所对应的底层结构图为：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png" width="500px"> </div><br>
每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。

```java
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

get() 方法类似。

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。

在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。

### 3. 可重入代码（Reentrant Code）

这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

- 
