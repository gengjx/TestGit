## 项目的亮点：

**1.使用分布式Seesion，可以实现让多台服务器同时可以响应。
2.使用redis做缓存提高访问速度和并发量，减少数据库压力，利用内存标记减少redis的访问。
3.使用页面静态化，加快用户访问速度，提高QPS，缓存页面至浏览器，前后端分离降低服务器压力。
4.使用消息队列完成异步下单，提升用户体验，削峰和降流。
\5. 安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。**

**主要知识点：**

- **分布式Seesion**
  我们的秒杀服务，实际的应用可能不止部署在一个服务器上，而是分布式的多台服务器，这时候假如用户登录是在第一个服务器，第一个请求到了第一台服务器，但是第二个请求到了第二个服务器，那么用户的session信息就丢失了。
  解决：session同步，无论访问那一台服务器，session都可以取得到，利用**redis缓存的方法，另外使用一个redis服务器专门用于存放用户的session信息。这样就不会出现用户session丢失的情况**。（每次需要session，从缓存中取即可）
- **redis缓解数据库压力**
  本项目大量的利用了缓存技术，包括用户信息缓存（分布式session），商品信息的缓存，商品库存缓存，订单的缓存，页面缓存，对象缓存减少了对数据库服务器的访问。
- **通用缓存key封装**
  大量的缓存引用也出现了一个问题，如何识别不同模块中的缓存（key值重复，如何辨别是不同模块的key）
  解决：利用一个抽象类，定义BaseKey（前缀），在里面定义缓存key的前缀以及缓存的过期时间从而实现将缓存的key进行封装。让不同模块继承它，这样每次存入一个模块的缓存的时候，加上这个缓存特定的前缀，以及可以统一制定不同的过期时间。
- **页面静态化（前后端分离）**
  页面静态化的主要目的是为了加快页面的加载速度，将商品的详情和订单详情页面做成静态HTML（纯的HTML），数据的加载只需要通过ajax来请求服务器，并且做了静态化HTML页面可以缓存在客户端的浏览器。
- **消息队列完成异步下单**
  使用消息队列完成异步下单，提升用户体验，削峰和降流
  **思路：**
  1.系统初始化，把商品库存数量stock加载到Redis上面来。
  2.后端收到秒杀请求，Redis预减库存，如果库存已经到达临界值的时候，就不需要继续请求下去，直接返回失败，即后面的大量请求无需给系统带来压力。
  3.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品，判断是否重复秒杀。
  4.库存充足，且无重复秒杀，将秒杀请求封装后消息入队，同时给前端返回一个code (0)，即代表返回排队中。（返回的并不是失败或者成功，此时还不能判断）
  5.前端接收到数据后，显示排队中，并根据商品id轮询请求服务器（考虑200ms轮询一次）。
  6.后端RabbitMQ监听秒杀MIAOSHA_QUEUE的这名字的通道，如果有消息过来，获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）。
  7.此时，前端根据商品id轮询请求接口MiaoshaResult,查看是否生成了商品订单，如果请求返回-1代表秒杀失败，返回0代表排队中，返回>0代表商品id说明秒杀成功。
- **安全性优化**
  双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。
- **优雅的代码编写**
  接口的输出结果做了一个Result封装
  对错误的代码做了一个CodeMsg的封装
  访问缓存做了一个key的封装





## 1. 使用JMeter做压测的时候开启5000个线程，系统跑不起来，出现异常

原因：修改配置文件中redis的配置项poolMaxTotal 将其设置成1000。

```xml
#redis配置项
redis.poolMaxTotal=1000
redis.poolMaxldle=500
redis.poolMaxWait=500
1234
```

## 2.使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题？

- **缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。**
  解决方案：对这些不存在的数据缓存一个空数据，对这类请求进行过滤。

- **缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。**
  解决方案：
  为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；
  为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
  也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。
  例如：首先针对不同的缓存设置不同的过期时间，比如session缓存，在userKey这个前缀中，设置是30分钟过期，并且每次用户响应的话更新缓存时间。这样每次取session,都会延长30分钟，相对来说，就减少了缓存过期的几率

- **缓存一致性要求数据更新的同时缓存数据也能够实时更新。**

  解决方案：
  在数据更新的同时立即去更新缓存，**首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。**
  在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新，**需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。**

## 3.大量的使用缓存，对于缓存服务器，也有很大的压力，思考如何减少redis的访问？

在redis预减库存的时候，内存中维护一个isOvermap作为一个内存标记，当没有库存的时候，将其置为true。每次秒杀业务访问redis之前，查一下map标记，如果true说明没有库存，就直接返回失败，无需再去请求redis服务器。

## 4.在高并发请求的业务场景，大量请求来不及处理，甚至出现请求堆积时候？

消息队列，用来异步处理请求。每次请求过来，先不去处理请求，而是放入消息队列，然后在后台布置一个监听器，分别监听不同业务的消息队列，有消息来的时候，才进行秒杀业务逻辑。这样防止多个请求同时操作的时候，数据库连接过多的异常。

## 5.怎么保证一个用户不能重复下单？

解决：秒杀订单表中建立一个唯一索引（所引是用户Id与商品goodsId），使得第一个记录可以插入，第二个则出错，然后通过事务回滚，防止一个用户同时发出多个请求的处理，秒杀到多个商品。

唯一索引，即是唯一的意思，在数据库表结构中对字段添加唯一索引后进行数据库进行存储操作时数据库会判断库中是否已经存在此数据，不存在此数据时才能进行插入操作。

这虽然是个小技能，但实际上在业务开发中是个很实用的技能，比如在高并发业务中，数据库**如何杜绝数据并发插入两条相同的订单号呢？添加一个唯一索引**当然是最快捷的方法之一，当然是添加索引还是通过业务代码去解决因公司业务而定

## 6.怎么解决超卖现象？

超卖场景：不同用户在读请求的时候，发现商品库存足够，然后同时发起请求，进行秒杀操作，减库存，导致库存减为负数。

最简单的方法，更新数据库减库存的时候，进行库存限制条件，在reduceStock(GoodsVo goodsvo)这个方法里，sql要多加一个stock_count > 0 ，使用数据库特性来保证超卖的问题，只有stock_count还大于0的时候才去读stock_count然后减1操作

```java
@Update("update miaosha_goods set stock_count=stock_count-1 where goods_id=#{goodsId} and stock_count>0")
	public void reduceStock(MiaoshaGoods goods);  
12
```

## 7.页面静态化的过程及什么是浏览器缓存？

将HTML静态页面缓存在客户端浏览器，只有数据通过ajax异步调用接口来获取，仅仅交互的是部分数据，减少了带宽，也加快用户访问的速度。

浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。

## 8.秒杀架构设计理念？

- 限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。
- 削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有利用缓存和消息中间件等技术。
- 异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。
- 内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。
- 可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。

## 9.秒杀系统是怎么设计的？

- **将请求拦截在系统上游，降低下游压力：秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，最终请求超时。**
- 利用缓存：利用缓存可极大提高系统读写速度。
- 消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809145433367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyYWRfUGlUdDc=,size_16,color_FFFFFF,t_70)

## 10.假如减了库存用户没有支付，库存怎么还原继续参加抢购?

设定一个最长付款时间，比如30分钟，后台有个定时任务（使用定时器Timer），轮训超过30分钟的待付款订单(数据库里面判定订单状态)，然后关闭订单，恢复库存。







## 11.秒杀流程

1. 登录进入商品列表页面，静态资源缓存
2. 点击进入商品详情页面，静态资源缓存，Ajax获取验证码等动态信息
3. 点击秒杀, 将验证码结果和商品ID传给后端，如果结果正确。动态生成随机串UUID,结合用户ID和商品ID存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务
4. 服务端获取请求的path参数，去查缓存是否在
5. 如果存在，并且Redis还有库存，预减redis库存，看是否已经生成订单，没有的话就将请求入消息队列
6. 从消息队列中取消息：获取商品ID和用户ID，判断数据库库存，然后下单
7. 下单：减库存，生成订单
8. 前端轮询订单生成结果。50ms继续轮询或者秒杀是否成功和失败







## 五. 页面优化技术

1. 内容

   - 页面缓存+URL缓存+对象缓存
   - 页面静态化，前后端分离
   - 静态资源优化
   - CDN优化

2. 页面缓存+URL缓存+对象缓存

   - 秒杀的瓶颈在于数据库，所以要加上各种粒度的缓存，最大的是页面缓存、最小的是对象缓存
   - 页面缓存步骤（这里指的是商品列表）：
     - 从redisService中取缓存
     - 若缓存中没有则手动渲染，利用thymeleaf模板
     - 然后将页面加入缓存，并返回渲染页面
     - 不宜时间太长，设置为60s即可
   - URL缓存（指的是商品详情页）
     - 与页面缓存步骤基本一致，但是需要取缓存和加缓存时要加入参数，GoodsId
   - 对象缓存（指的是User对象）
     - 前面的页面缓存和URL缓存适合变化不大的，缓存时间比较短
     - 对象缓存是长期缓存，所以需要有个更新的步骤
     - 第一步是取缓存
     - 若缓存中没有则去数据库中查找，并加入缓存；如数据库中没有就报错
     - 更新用户的密码
   - 加缓存之后的QPS大概3000
   - 需要先更新数据库，后删除缓存；顺序不能反，会导致数据不一致：若线程1先删除缓存，然后线程2读操作，发现缓存中没有，把数据库中的旧数据加入缓存，然后线程1更新数据库，就会导致缓存与数据库数据不一致

3. 页面静态化，前后端分离

   - 页面静态化无非就是使用纯html页面+Ajax请求json数据后再填充页面
   - 若A页面跳转到B页面之前需要条件判断可以先在A页面中利用ajax请求判断后再跳转
   - 如果不需要条件判断可以直接跳转到B的静态页面，让B自己用ajax请求数据

4. **防超卖**

   - 发生在减库存的时候
   - 解决方法是在Update语句中加一个判断

   [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pBQCw6T3-1596466141006)(https://s3-us-west-2.amazonaws.com/secure.notion-static.com/752fa7ac-cacc-4761-90a7-36803e689e22/Untitled.png)]

   - 还有一种情况是一个用户同时发了两个请求，假如库存充足，且没有订单生成，那么就会减两次库存
   - 解决办法是建立用户和商品的唯一索引
   - **做到以上两点是不会发生超卖的**

5. CDN优化

- CDN是内容分发网络，相当于缓存，只是部署在全国各地，当用户发起请求时，会找最近的CDN获取资源
- **总结：**并发大的瓶颈在于数据库，所以解决办法是加各种缓存：从浏览器开始，做页面的静态化，将静态页面缓存在浏览器中；请求到达网站之前可以部署一些CDN，让请求首先访问CDN；然后是页面缓存、URL缓存、对象缓存；
- 加缓存的缺点：数据可能不一致，只能做一个平衡

## 六. 接口优化

1. 内容
   - Redis预减库存减少数据库访问
   - 内存标记减少Redis访问
   - RabbitMQ队列缓冲，异步下单，增强用户体验
   - RabbitMQ安装与Spring Boot集成
   - 访问Nginx水平扩展
   - 压测
2. **思路：减少数据库访问**
   - 系统初始化，把商品库存数量加载到Redis中
   - 收到请求，Redis预减库存，库存不足，直接返回，否则进入3
   - 请求入队，立即返回排队中
   - 请求出队，生成订单，减少库存
   - 客户端轮询，是否秒杀成功
3. 优化思路
   - 系统初始化，把商品库存数量加载到Redis
   - 收到请求，Redis预减库存，库存不足，直接返回，否则进入3
   - 请求入队，立即返回排队中（异步下单）
   - 请求出队，生成订单，减少库存，把订单写入Redis中
   - 客户端轮询，判断是否秒杀成功
4. 秒杀接口优化
   - 之前的没有库存预热的步骤是：查库存-查订单-修改库存-生成订单
   - 系统初始化时把库存加载到数据库：MiaoshaController 继承InitializingBean实现afterPropertiesSet方法即可
   - 在上一步库存预热之后，执行步骤为：查Redis库存-判断是否存在订单-进入队列-在出队时才对数据库进行操作
   - 这一步还可以有一个优化，就是**内存标记**，使用一个Map，将商品ID设置为false，当买空时，设为true；然后每次不是直接访问Redis进行库存查询，而是对商品ID进行条件判断
   - 内存标记的优点是减少对Redis的访问（当商品已经卖完之后）

## 七. 安全优化

1. 主要内容
   - 秒杀接口地址隐藏
   - 数学公式验证码
   - 接口限流防刷
2. 秒杀接口地址隐藏
   - 虽然前端页面在秒杀未开始时秒杀按钮设置为不可用，但是有可能用户通过前端js代码找到秒杀地址在秒杀未开始时直接访问，秒杀接口隐藏的目的是用户通过js获取到的秒杀地址并不能让其完成秒杀功能
   - 在秒杀之前要先通过Controller中的/path路径下的类随机生成一个path，然后和用户ID一起存入Redis，在执行秒杀的时候再从Redis中取Path进行验证，然后进行秒杀
3. 数学公式验证码
   - 作用：接口防刷；错开请求
   - 在获取Path是进行验证
4. 接口限流防刷
   - 当一个用户访问接口时，把访问次数写入缓存，并设置有效期
   - 一分钟之内如果用户访问，则缓存中的访问次数加一，如果次数超限进行限流操作
   - 如果一分钟内没有超限，缓存中数据消失，下次再访问时重新写入缓存
5. 使用一个通用拦截器
   - 首先写一个注解AccessLimit
   - 后面每个类只需要加注解即可设置防刷次数
   - 定义拦截器：继承HandlerInterceptorAdapter类

## 问题

**2.项目可改进的地方**

- 对于数据的动静分离没有做的很彻底，只是用到了浏览器缓存，没有使用CDN等技术
- 没有设置降级的方案
- 限流做的不够完善，目前只对用户对于某个商品的访问做了限流，没有对整体的流量做限流，比如不法分子有非常多的账号，同时对一个商品发起请求可能造成我们的服务不可用。
- 没有考虑redis穿透的情况处理方案
- 在这个项目中是对库存和静态数据进行了预热，但是实际中有可能某个商品可能一时间快速爆火，如果没有对这些是商品数据进行预热可能会使服务宕掉，需要快速发现热点数据的发现与隔离，比如某明星粉丝约定某一时刻购买某粉丝代言的产品，虽然该商品没有参加秒杀活动，但那一时刻也胜似秒杀
- 对于部署还没有进行实际的操练和学习，可以使用Ngnix做负载均衡

**3.讲一下秒杀流程**

- 用户在秒杀商品详情页面点击秒杀按钮
- 向服务器端请求秒杀路径，主要逻辑为生成随机path值存入redis中，根据此path值拼凑秒杀路径。
- 访问拼凑的秒杀路径，先验证路径中path是否在redis中存在，如果不存在直接返回错误。
- 利用本地缓存，redis缓存做预减库存对请求做分层过滤
- 在一个事务中完成减库存下订单的过程

**4. 分布式Session是怎么实现的**

- 用户登录后生成随机字符串，并向cookie中写入此字符串。
- 在Redis中记录此字符串和用户信息的映射
- 当用户再次访问网页时，取出cookie中对应字段值，根据此字段值访问Redis得到用户相关信息

**5.如何解决超卖?**

- 超卖问题主要依靠MySQL中排它锁实现的
- 在减库存时设置sql语句where中stock>0

**6.如何解决重复下单？**

- 执行减库存下订单逻辑前，判断是否在订单表中含有用户秒杀此商品的记录
- 利用唯一索引，在订单表中创建user_id和good_id组成的唯一索引，这样在重复插入数据的时候会插入失败，之前的减库存操作在事务中也会回滚。

**7. 如何防刷？**

- 对一个商品秒杀时Redis会记录一个用户对一个商品的秒杀按钮的点击次数，如果用户对按钮点击次数超过5次直接返回多次请求提示
- 但是并没有对所有流量进行限流（具体见项目的不足第二条）

**8. 消息队列的作用？**

- 削峰，减少同一时刻并发量
- 入队后直接返回用户排队中消息，提高用户体验

**9. 压测？**

- JMeter压测
- 10个线程一秒5000并发量，未优化前1300QPS，优化后2100QPS
- 虚拟机4核4G，未实际部署

**10. 库存预减用的是哪个redis方法？**

- 使用Jedis封装相关方法，减库存使用decr方法

**11. 缓存和数据库数据一致性如何保证？**

- 对于库存数据不需要保证，缓存中的库存只为了过滤请求，即使多放进来一些请求我们也可以在数据库层面保证不超卖。
- 对于商品信息的静态数据也不需要保证数据一致性，因为不会变

**12. 如果项目中的redis服务挂掉，如何减轻数据库的压力**

- 设置本地缓存
- 设置限流降级功能
- 做好参数校验

**13. 假如减了库存但用户没有支付，怎么将库存还原继续进行抢购**

- 订单超时未支付则删除订单，增加库存数量，恢复Redis缓存和本地缓存的数量
- 但是对于秒杀项目之所以采用下订单减库存而不是付款减库存不就是因为秒杀商品秒到就是赚到大概率不会不付款嘛。另外即使不付款，那就不会发货，只会少卖不会超卖对于商户也不会有什么损失吧。

**14. 系统瓶颈在哪？**

- 数据库
- 服务端网络，CPU和内存等硬件资源
- 对于服务端网络带宽可以向isp购买，服务器端硬件资源的话可以尽可能的加
- 另外可以减少耗费CPU和内存的操作，比如编码操作，序列化操作，频繁创建大对象的操作，防止出现内存泄漏
- 以上可以通过查看服务器运行时资源占用情况判断。

**15. 如何再优化？**

- 彻底的动静分离上CDN
- 可以考虑把第二条的东西说说吧
- 我不知道了啊。。。

**16. 项目难点及问题解决？**

- 数据一致性：防止超卖和重复下单
- 如何应对高并发：你懂得
- 如何保持高可用：你懂得
- 接口防刷

**17.秒杀接口隐藏问题**

- 用户点击按钮时首先请求一个路径，之后在拼接该路径完成真正的秒杀请求
- 用户可以知道获取path的url并发出请求，但是如果不对路径进行拼接就不会发出秒杀请求。



##  优化秒杀流程

1. 秒杀活动开始之前有个活动倒计时，时间到了则会放开秒杀的权限，并生成一个验证码展示在前面页面，并把验证结果存在redis中，这里利用redis有过期时间的特性，也给验证码的缓存加了个过期时间。这里的redis缓存用的是redis的string类型。
2. 在秒杀之前先要填一个**验证码**verifyCode，点击秒杀按钮时，先发送ajax请求到后台获取真实的秒杀地址path，这里秒杀地址是隐藏的，目的是**防止有人恶意刷秒杀接口**。所谓**隐藏地址**，其实是在请求地址中加一段随机字符串，这段字符串是变化的，因此秒杀请求地址是动态的；
3. 先说下如何获取真实的秒杀地址，后台先访问redis，验证一下这个验证码有没有过期以及这个verifyCode是不是正确，验证码验证通过后，先删除这个验证码缓存，然后生成真实地址；
4. 真实地址随机字符串由uuid以及md5加密生成，并且保存在redis中，并且设置了有效期；
5. 从浏览器端向秒杀地址发起请求，带上path参数去后台调用真正的秒杀接口，下面是**秒杀接口的逻辑**；
6. 访问redis，验证path有没有过期，以及是不是正确。这里验证path以及上面的校验验证码，都是用userId对应生成的一个key值去取redis中的数据；
7. path验证通过后，先访问**内存标识**，看秒杀的这个商品有没有卖完，减少对redis的不必要访问。每一种参与秒杀活动的商品都在内存里用HashMap设置了一个标识，标识某个商品id商品是否卖完了。这里的是否卖完的内存标识设置以及每种参与秒杀商品的库存存入redis是在系统启动时做的；
8. 如果内存标识中这个商品没有卖完，则要看这个用户在这次活动中是否**重复秒杀**，因为我们的秒杀规则是一个用户id对于某个商品id的商品只能秒杀一件。如何判断该用户有没有秒杀过这件商品呢，**秒杀记录也保存在****redis****缓存中**；
9. 如果判断秒杀过则返回提示，如果没有秒杀过，继续；
10. 上面说过系统加载时redis中保存了各商品对应的库存，这里用到**redis****的原子操作**的方法decr，将对应商品的库存减1，此时数据库时的库存还没有减，因此是**预减库存**；
11. desc方法返回该商品此时的库存，如果小于0，说明商品已经卖完了，此次秒杀无效，并且设置该商品的**内存标识为****true****，表示已卖完**；
12. 正确地预减库存后，然后就要真正操作数据库了，数据库一般是性能瓶颈，比较耗时，因此决定用**异步方式**处理。对于每一条**秒杀请求存入消息队列****RabbitMQ**中，消息体中要包含**哪个用户秒杀哪个商品的信息**，这里是封装了一个消息体类，这样一个秒杀请求就进入了消息队列，一个秒杀请求还没有完成，真正的秒杀请求的完成得要持久化到数据库，生成订单，减了数据库的库存才能算数，这时在客户端显示的一般是**排队中**，比如以前在抢购小米手机时，我就看到这样的展示，过一会再刷新页面就显示没抢到；
13. **消息队列处理秒杀请求**。先从消息体中解析出用户id和商品id，**查数据库看这个商品是否卖完了**，**查数据库看该用户对于这个商品是否有过秒杀记录**；**数据库减库存，数据库生成订单**，这两项持久化地写数据库操作放在同一个事务中，要么都执行成功，要么都失败。并**把秒杀记录对象**，包括秒杀单号、订单号、用户id、商品id，**存入****redis****中**。**如果数据库减库存失败，表明商品卖完了，则要在****redis****中设置该商品已卖完的标识**。**消息队列处理秒杀请求**。先从消息体中解析出用户id和商品id，**查数据库看这个商品是否卖完了**，**查数据库看该用户对于这个商品是否有过秒杀记录**；
14. **数据库减库存，数据库生成订单**，这两项持久化地写数据库操作放在同一个事务中，要么都执行成功，要么都失败。并**把秒杀记录对象**，包括秒杀单号、订单号、用户id、商品id，**存入****redis****中**。**如果数据库减库存失败，表明商品卖完了，则要在****redis****中设置该商品已卖完的标识**。
15. ajax发起秒杀请求，秒杀请求的处理逻辑最后也只是把这条请求放入消息队列，并不能返回是否秒杀成功的结果。因此，当秒杀请求正确响应后，即请求放入消息队列后，需要另外一个请求去**轮询秒杀结果**，秒杀成功的标志是生成秒杀订单，并把秒杀订单对象放入redis中。所以轮询秒杀结果，只用去轮询redis中是否有对应于该用户的该商品的秒杀订单对象，如果有，则表明秒杀成功，并在前台给出提示。





## 4. 问题解析

**4.1 如何解决库存的超卖问题？**

数据库自身是有行级锁的，每次减库存的时候判断count>0就行。

UPDATE seckill

​    SET number = number-1

​    WHERE seckill_id=#{seckillId}

​    AND start_time <#{killTime}

​    AND end_time >= #{killTime}

​    AND number > 0;

 4.**2.** **如何解决少卖问题？**

前面的方案中会出现一个少卖的问题。Redis在预减库存的时候，在初始化的时候就放置库存的大小，redis的原子减操作保证了多少库存就会减多少，也就会在消息队列中放多少。

现在考虑两种情况：1）数据库那边出现非库存原因比如网络等造成减库存失败，而这时redis已经减了。2）万一一个用户发出多个请求，而且这些请求恰巧比别的请求更早到达服务器，如果库存足够，redis就会减多次，redis提前进入卖空状态，并拒绝。不过这两种情况出现的概率都是非常低的。

两种情况都会出现少卖的问题，实际上也是**缓存和数据库出现不一致的问题**！

但是我们不是非得解决不一致的问题，本身使用缓存就难以保证强一致性：

在redis中设置库存比真实库存多一些就行。

**4.3 秒杀过程中怎么保证redis缓存和数据库的一致性？**

在其他一般读大于写的场景，一般处理的**原则**是：**缓存只做失效，不做更新。**

采用Cache-Aside pattern：

**失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。

**更新**：先把数据存到数据库中，成功后，再让缓存失效。

**4.4 一个秒杀系统，****500****用户同时登陆访问服务器****A****，服务器****B****如何快速利用登录名****(****假设是电话号码或者邮箱****)****做其他查询？**

主从复制，读写分离