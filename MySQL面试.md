### 1.MyIASM和Innodb索引的数据结构？

```
都是B+树!

MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。

Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。


```

### 2.什么是索引？



```
索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。

你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。

```

### 3.索引底层数据结构是？

```
（1）底层数据结构是B+树：

在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。

（2）使用B+树的原因：

查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（此时，你应该在白纸上画出什么是B+树）
```

### 4.索引的分类？

```
- 唯一索引：唯一索引不允许两行具有相同的索引值
- 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。
			主键索引要求主键中的每个值是唯一的，并且不能为空
- 聚集索引：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个
- 非聚集索引：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个
```



### 5.索引的优缺点？

```
（1）优点：
- 大大加快数据的检索速度，这也是创建索引的最主要的原因；
- 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间；
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

2）缺点：
- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
- 空间方面：索引需要占物理空间。
```



### 6.什么样的字段适合创建索引？

```
- 经常作查询选择的字段
- 经常作表连接的字段
- 经常出现在order by, group by, distinct 后面的字段
```



### 7.创建索引时需要注意什么？

```
- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；

- 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；

- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
```



### 8.MyISAM 和 InnoDB的区别

```
    1. 【是否支持行锁】
        MyISAM 仅支持表锁， InnoDB支持表锁和行锁
        
    2. 【是否支持事务】 
        MyISAM不支持事务，且不具备【崩溃恢复能力】。
        InnoDB 支持事务，提供回滚和崩溃恢复。
    
    3. 【是否支持外键】
        仅InnoDB支持外键 
    4. 【是否支持MVCC】
        仅InnoDB支持MVCC
    
    5. 【应用场景不同】
        MyISAM 适用 【Select】频繁，并发少
        InnoDB 适用 【Insert Delete Update】频繁，高并发

        因为 
        (1) MyISAM 仅缓存索引块，而InnoDB缓存 {索引+数据}
        (2) InnoDB 回表需要映射块，而MyISAM 直接映射数据地址
        (3) InnoDB 需要维护MVCC机制
        
    6.  MyISAM索引 和 InnoDB 索引 区别
        MyISAM 【索引】 叶子节点 = {key ， 行数据地址}
        
        InnoDB 【主键索引】 叶子节点 = {主键ID ， data数据}
        因此 InnoDB根据【主键】索引查询，不需要二次寻址，效率更高
        
        InnoDB 【二级索引】 叶子节点 = {key, 主键ID}
        如果过实现索引覆盖，即 要查询列值 全部命中索引，则直接返回 非主键索引的内容
        如果为实现索引覆盖，则需要根据【主键ID】做回表
    
    7.  【存储结构不同】
        InnoDB 存储结构 = 索引和数据 集中存储
        MyISAM存储结构 = {表定义，MYD数据文件，MYI索引文件}
    
    8.  不带WHERE条件时，【count(*)效率不同 】
        MyISAM 自带计数器存储保存【总行数】，可直接返回结果
        InnoDB 扫描全表计算总行数
```



### 11.并发事务带来的问题

```
    1. 脏读 
        事务A 修改数据，但并未commit。而事务B读取该数据。 
    2. 丢失修改
        事务A 、B都读取同一个数据。事务A 、B先后修改数据，则 第一次修改操作丢失。
    3. 不可重复读
        事务A 共读取两次数据，而在这两次读取之间。事务B修改了数据。则事务A两次读取到的数据不同。
    4. 幻读 
        事务A 读取【n行数据】,事务B在n行数据间添加数据。则事务A第二次读取时，读取到n+1行。
```

### 12. 事务隔离级别

```
    1. Read-Uncommitted 读取未提交
        无论事务是否提交，直接【读取主记录】 
        即并发问题 =【脏读】+【不可重复读】+【幻影读】
    2. Read-committed 读取已提交
        【读取最新版本的快照】，快照是事务提交后产生，但可能存在同一事务两次读取的快照不同。
        即并发问题 = 【不可重复读】+【幻影读】
    3. Repeatable 可重复读
        【读取指定版本快照】，则事务多次读取某数据行的结果一致，但读取到的数据可能并非最新数据 。
        即并发问题 = 【幻影读】
    4. Serializable 可串行化 
        上表锁，读写相互阻塞。效率低下。
        无并发问题 
        
    InnoDB引擎默认实现 可重复读隔离级别 
    
```

### 13. MVCC

```
【目的】 ： 
    MVCC是行锁的变种，它想要尽可能地避免加锁操作，实现【非阻塞】读。从而提高处理并发事务的性能

【MVCC 实现的隔离级别】
    MVCC仅 Read Committed & REPEATABLE READ 两种隔离级别
    READ UNCOMMITTED 总是【读取最新】数据行 ，与MVCC的版本快照机制不符
    SERIALIZABLE 则 对读取的【数据行】都加锁 ，与MVCC 尽可能避免加锁的原则不符
    
【undolog】 记录数据行的某个历史版本，undolog以链表形式存在

RC 是读取 最新版本的 undolog
RR 是读取 某一指定老版本的undolog
```



### 14. Hash索引

```
(1) hash 索引的实现 
    底层数据结构 = hash表
    通过hash值定位数据行，产生碰撞则采用拉链法解决。
(2) hash索引的缺点 
    1. 适用于等值查询。
       但hash索引无法排序，因此不适用于范围查询，不支持最左匹配原则。
    2. 大量重复的键值，减低效率、
```

### 15. 磁盘预读取

```
磁盘读取以【磁盘块】为基本单位。
【磁盘预读取】：每次读取多个【物理连续】的磁盘块
B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。
一页空间 = 磁盘预读取的 多个磁盘块总和
从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数
```

### 16.为什么使用B+树，而不是 B树

```
1.  Mysql根据【磁盘IO次数】衡量查询效率，而【B+树磁盘IO次数更少】

    因为 B+树中【 非叶节点 = { 指针+key } 】
    而B树中 【非叶节点 = { 指针+ key + data数据 }】,
    每个节点(即每一页) 存储空间有限，B树节点存储的key较少，出度较小
    因此B树的节点较多(key总量固定)
    导致B树深度较大，磁盘IO次数多。
    
2.  B+树叶子节点通过指针连接，便于【区间访问】
```

### 17. 为什么使用 B+树，而不是红黑树

```
【B+树磁盘IO次数更少】 
1.  红黑树的深度往往较大，而磁盘IO次数是和树高度成正比。
2.  
    B树利用磁盘预读取特性。在建立节点时，申请【物理连续】的一页空间。
    一页空间 = 磁盘预读取的 多个磁盘块总和
    从而 【实现一次磁盘IO读取一个节点】，减少磁盘IO次数
    
    红黑树上逻辑较近的节点，其物理距离可能较远。无法利用磁盘预读特性
```

### 18.聚簇索引和非聚簇索引 

```
聚簇索引 = 将索引结构和数据放在一起的索引
【优点】：查询效率高，定位到索引树叶节点，就直接找到数据
【缺点】： 索引列更新时，维护代价大
【主键索引】属于【聚簇索引】

非聚簇索引 = 索引结构和数据分离的索引
【优点】： 更新代价小 
【缺点】： 需要二次查询，
        例如 二级索引需要在主键索引中再次回表查询
【二级索引】属于【非聚簇索引】
```



### 19.主键索引和二级索引

```
主键索引 叶子节点 = {key,其他data数据} 
InnoDB中如果没有指定表的主键，则检测表是否有唯一索引
如果有，则该字段默认 = 主键
如果没有， 则InnoDB自动创建6B的自增主键

二级索引 叶子节点 = {key，主键ID}
二级索引查询【过程】
    1. 【非聚集索引】中查询到主键ID
    2. 【回表】 ： 根据主键ID在  【聚集索引】中查询整行记录
```



### 20. 最左前缀

```
联合索引 是由多个列组成。如(name,age)
查询时，列值【从左到右】匹配索引。
遇到【范围查询】(> < between like左匹配)后 ，不可进一步匹配。
```

### 21. 覆盖索引

```
在非聚集索引的叶子节点中 所含的列值是要查询的列值，不用进行回表。直接返回即可
```

### 22.为什么不对每个列创建索引

```
1. 数据CRUD时， 索引需要动态维护
2. 索引占据物理空间，尤其聚簇索引
```



### 23.索引应用场景

```
ALTER TABLE add index(字段名) 创建索引
    1. WHERE 
    WHERE 筛选字段进行查询时，
    如果 该字段建立索引，则查询效率更高
    
    2. ORDER BY  
   
    使用order by将查询结果按照某个字段排序时，
    
    如果该字段没有建立索引，
    查询出的所有数据使用外部排序，涉及磁盘IO，则效率底下
    
    ALTER TABLE table_name ADD INDEX index_name (column_list);
    由于索引有序，所以按照索引顺序逐条读出数据
    
    3. 索引覆盖
    【查询的字段】都建立过索引，
    引擎会直接在索引表中查询而【不访问原始数据】
    尽可能在select后只写必要的查询字段，以增加索引覆盖的几率
```

### 24. 创建索引的原则

```
    1. 字段 基数大
    2. 字段 重复值较少 
    3. 字段 频繁作为【查询条件】
    4. 字段 更新少 
    5. 最左匹配原则 ：  
        MySQL对 索引中的列值 从左到右匹配，直到遇到范围查询就停止
    6. 尽量扩展索引，而非创建新索引
    
```



### 25.大表优化

```
1. 限定数据范围 
    查询语句 通过查询条件限定数据范围
2. 数据库主从同步，读写分离
    多个服务器上部署mysql，
    一台服务器为【主库】，负责【写数据】
    其他服务器为【从库】，负责【读数据】
    
    一. 主从同步实现
    【主库A】数据库事件存储在 日志系统A中，传输日志文件
    【从库】 接收文件并写入本地日志系统，然后将【数据库事件】在从库MySQL中完成

3. 垂直分区
    
    优点：一行记录 的数据量变少，在查询时IO次数减少
    
    缺点：
        (1) 主键冗余，
        (2) 引起join操作
4. 水平分区
    将 【行数据】分组存储到不同【库 ||表】， 【最好分库】
    
    【缺点】：
        (1) 查询时，通常需要 【多个表名】 + 【UNION操作】
        (2) 跨库 JOIN 性能很差 , 
        (3) 【跨库】的【事务支持】，逻辑复杂度和性能代价 都很大

            
```



### 26.分表 分库后的问题

```
        (1). 【跨节点】的 count，order by ， group by 等【聚合函数】逻辑复杂
        (2). 【跨库】的join 性能代价大
        (3). 【主键ID问题】 ：MySQL原先主键自增机制，跨库情况下，存在主键重复的问题
           1)  若采用 UUID作为主键， 则UUID主键占用内存过大
           2)  多个数据库采用 跨步自增
           3) ...
        (4) 【事务支持】
```



### 27.主从分布，读写分离

```
        作用 = { 负载均衡 + 数据备份 + 高可用}
        流程 ={
            1. 主库的【数据库事件】记录在二进制的binlog，binlog传输给从库
            2. 从库读取binlog内容到本地日志系统的relaylog
            3. 从库 执行relay log中的SQL语句，实现主从同步
        }
```



### 28. SQL生命周期

```
1. 应用服务器与数据库服务器建立一个连接，应用服务器发送SQL请求

2. 数据库进程拿到【sql请求】，通过【连接器】验证SQL语句是否具有【权限】

3. 【分析器】进行 词法分析和语法分析。 
    词法分析 提取SQL语句关键元素 ： SELECT 、 表名 、 查询条件等
    语法分析 判断SQL语句是否正确 ：判断关键词是否正确

4. 【优化器】生成SQL【执行计划】
    
5. 【执行器】按照执行计划， 将数据读取到内存并进行逻辑处理

6. 通过连接，将数据传输给应用服务器 

7. 断开连接
```

### 29. MySQL锁

```
1. 表锁
2. 行锁
3. 间隙锁
 	1. Record Lock :  单个数据行的锁
    2. Gap Lock ： 锁定范围，不包括记录本身
    3. Next-key lock : record + gap 结合，锁定一个范围，并且锁定记本身
```

### 30. count* count1 count(col)区别

```
count(expression) = 聚合函数
	逐行检测expression是否=null, 
	expression！=null则计数器加1
	
count(1)和count(*)作用相同:
	count(1) 每行expression=1 ，NOT NULL，count(1)作用=统计总行数
	count(*) 并非 统计每行所有列值是否为null，列值全为null的数据行不存在.
	因此 count(*) = 统计总行数
	
count(1) count(*) 经过优化器指定的执行计划相同 ，两者效率相同
	在没有二级索引情况下， 通过主键索引统计总行数
	如果有二级索引， 则优先选择 【最窄】二级索引统计总行数 
	主键索引 叶节点 = {主键ID, 其他所有列值}
	二级索引 叶节点 = {key+主键ID}
	
count(col) 逐行检测col是否=null
	因此 count(col)统计 非null列的总行数
	对col建立非聚集索引，可以优化查询效率
```



### 31.explain 返回的结果

```
type ：引擎查找表的方式
	all,index,range,ref,eq_ref，const
	从左到右，它们的效率依次是增强的 
    all     全表扫描
    index   全索引扫描
    range   范围扫描 ：     【索引】+【范围查询】
    ref     小范围扫描：    【可能重复】的【普通索引】+【表联结情况】
    eq_ref  单条数据扫描 ： 【主键 || 唯一】索引+【表联结情况】
    const   单条数据扫描 ： 【主键 || 唯一】索引
    
key：   MySQL 使用的索引

rows：	MYSQL 执行查询的行数，数值越大性能越差

extra：
	Using index 使用覆盖索引
	Using Where 使用WHERE过滤
	Using temporary ： 使用临时表 ，建议优化
	Using filesort ： 对查询结果【外部排序】，而非根据索引有序读取。建议优化
```



### 32. WHERE的优化

```
1.全表扫描
	WHERE,ORDER BY涉及的列上 建立索引
	
2.WHERE条件中避免使用的判断
	{
        is null ,
        !=  ,
        OR  ,
        in  ,   //  慎重使用，非连续 in集合会放弃索引，全表扫描
    }
    这些判断，会使得引擎【放弃索引】，进行【全表扫描】

3. WHERE条件中 避免【运行时解析】的变量
	原因： 执行计划在【**编译期**】制定，【**运行时解析**】的变量不能作为索引输入项因此采用全表扫描
 	{
        1. 参数 
             WHERE num = @num
        2. WHERE条件左侧 避免 函数调用+算术计算 
            WHERE num = 100+2
            WHERE substring(num,1,3) = 'abc'
    }
```



### 33.超大分页

```
    超大分页 = Limit 10000，10 
    MySQL并非跳过= offset行，而是取offset+N行，然后返回放弃前offset行，返回N行
    那当offset特别大的时候，效率低下
    
    【优化方法】： 先快速定位 主键，然后再关联   
```

### 34. SQL优化

```
	1. 慢查询日志 ，查看开销大的SQL
		set GLOBAL slow_query_log = on
	2.  开销大原因 = {
   		1.  
          【原因一】：SQL语句 是否加载额外的数据 
          【例子】： 未使用WHERE范围限制、 Limit分页过大、 使用{is NULL，!= ，OR} 触发全表扫描
          【优化】 ： 修改SQL语句
                
         2. 
          【原因二】： 未命中索引、使用的索引有待优化
          【例子】： SELECT A,B,C FROM t WHERE A=? AND B= ? 
                            或者 ORDER BY 、ON的列上是否建立索引 
          【优化】：explain查询执行计划，创建||选择其他索引，使得SQL语句尽可能地命中索引
                
         3. 
           【原因三】： SQL语句无法优化，【大表情况】
             (1) 分库分表
             (2) 主从同步，读写分离
        } 
        
```



### 35.可以使用多少列创建索引？

```
任何标准表最多可以创建16个索引列。
```

### 36. 索引失效



### 37.索引，主键，唯一索引，联合索引的区别

```
索引：
	索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。
	
唯一索引：
	普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。
	
主键：
	是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。

联合索引：
索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。
```



### 38.索引对数据库的性能影响

```
索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。
```



### 39.索引的目的是什么？

```
快速访问数据表中的特定信息，提高检索速度
创建唯一性索引，保证数据库表中每一行数据的唯一性。
加速表和表之间的连接

使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
```



### 40.主键、外键和索引的区别？

```
定义：
	主键–唯一标识一条记录，不能有重复的，不允许为空
	外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值
	索引–该字段没有重复值，但可以有一个空值

作用：
	主键–用来保证数据完整性
	外键–用来和其他表建立联系用的
	索引–是提高查询排序的速度

个数：
	主键–主键只能有一个
	外键–一个表可以有多个外键
	索引–一个表可以有多个唯一索引
```

### 41. 回表查询？

```
就是数据库根据索引（非主键）找到了指定的记录所在行后，还需要根据主键再次到数据块里获取数据。
当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.
```

### 42. 非聚簇索引一定会回表查询吗?

```
	不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.
	假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.
```



### **43.联合索引是什么?**

```
MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.

MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.

-- 为什么需要注意联合索引中的顺序?
当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.
```



### 44.varchar(10)和int(10)

```
varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,
int的10只是代表了展示的长度,不足10位以0填充.也就是说,
	int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.
```

### 45.MySQL的binlog录入格式?

```
有三种格式,statement,row和mixed.

- statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候	需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
- row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动，
	因此这种模式的文件保存的信息太多,日志量太大.
- mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.

此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.

```

### 46.存储过程？

```
存储过程是一些预编译的SQL语句。1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全

但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.
```

